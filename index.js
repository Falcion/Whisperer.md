/* eslint-disable */
/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

'use strict'
var __defProp = Object.defineProperty
var __defProps = Object.defineProperties
var __getOwnPropDesc = Object.getOwnPropertyDescriptor
var __getOwnPropDescs = Object.getOwnPropertyDescriptors
var __getOwnPropNames = Object.getOwnPropertyNames
var __getOwnPropSymbols = Object.getOwnPropertySymbols
var __getProtoOf = Object.getPrototypeOf
var __hasOwnProp = Object.prototype.hasOwnProperty
var __propIsEnum = Object.prototype.propertyIsEnumerable
var __reflectGet = Reflect.get
var __defNormalProp = (obj, key, value) =>
  key in obj
    ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value })
    : (obj[key] = value)
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop])
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop])
    }
  return a
}
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b))
var __export = (target, all) => {
  for (var name in all) __defProp(target, name, { get: all[name], enumerable: true })
}
var __copyProps = (to, from, except, desc) => {
  if ((from && typeof from === 'object') || typeof from === 'function') {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, {
          get: () => from[key],
          enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        })
  }
  return to
}
var __toCommonJS = (mod) => __copyProps(__defProp({}, '__esModule', { value: true }), mod)
var __publicField = (obj, key, value) =>
  __defNormalProp(obj, typeof key !== 'symbol' ? key + '' : key, value)
var __superGet = (cls, obj, key) => __reflectGet(__getProtoOf(cls), key, obj)
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value))
      } catch (e) {
        reject(e)
      }
    }
    var rejected = (value) => {
      try {
        step(generator.throw(value))
      } catch (e) {
        reject(e)
      }
    }
    var step = (x) =>
      x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected)
    step((generator = generator.apply(__this, __arguments)).next())
  })
}

// source/main.ts
var main_exports = {}
__export(main_exports, {
  default: () => Whisperer
})
module.exports = __toCommonJS(main_exports)
var import_obsidian3 = require('obsidian')

// source/settings.ts
var import_obsidian2 = require('obsidian')

// source/settings/settings_class.ts
var import_obsidian = require('obsidian')
var SettingsConstructor = class _SettingsConstructor {
  constructor(_plugin, _containerEl) {
    __publicField(this, 'defaults')
    __publicField(this, '_SETTING_AMBIENCE')
    __publicField(this, '_SETTING_VAULT_PATH_TITLE')
    __publicField(this, '_SETTING_VAULT_PATH_INPUT')
    __publicField(this, '_SETTING_AMBIENCE_PER_FILE')
    __publicField(this, '_SETTING_AMBIENCE_PER_FILE_COMMENT')
    __publicField(this, '_SETTING_MUSICE_VOLUME')
    __publicField(this, '_SETTING_DEBUG_FRAMES')
    __publicField(this, 'plugin')
    __publicField(this, 'containerEl')
    this.plugin = _plugin
    this.containerEl = _containerEl
  }
  get SETTING_AMBIENCE() {
    if (!this._SETTING_AMBIENCE) {
      this._SETTING_AMBIENCE = new import_obsidian.Setting(this.containerEl)
        .setName('Vault ambience:')
        .setDesc(
          "If enabled, plugin would try to apply your embed URL as audio for the vault's ambience."
        )
        .addToggle((toggle) => {
          toggle.setValue(this.plugin.settings.vault_ambience).onChange((value) =>
            __async(this, null, function* () {
              const next = __spreadProps(__spreadValues({}, this.plugin.settings), {
                vault_ambience: value
              })
              yield this.plugin.updateSettings(next)
              _SettingsConstructor.updateDisplays(
                [this.SETTING_VAULT_PATH_TITLE, this.SETTING_VAULT_PATH_INPUT],
                [value, value]
              )
            })
          )
          return toggle
        })
    }
    return this._SETTING_AMBIENCE
  }
  get SETTING_VAULT_PATH_TITLE() {
    if (!this._SETTING_VAULT_PATH_TITLE) {
      this._SETTING_VAULT_PATH_TITLE = new import_obsidian.Setting(this.containerEl)
        .setName("Path/URL to the audio of Vault's ambience (supports YouTube, SoundCloud):")
        .setDesc(
          "Be aware, that some videos on YouTube are blocked to be played as embed, so they may be not working in the Obsidian's Vault."
        )
    }
    return this._SETTING_VAULT_PATH_TITLE
  }
  get SETTING_VAULT_PATH_INPUT() {
    if (!this._SETTING_VAULT_PATH_INPUT) {
      const result = new import_obsidian.TextAreaComponent(this.containerEl)
        .setPlaceholder('https://www.youtube.com/watch?v=dQw4w9WgXcQ')
        .setValue(this.plugin.settings.vault_ambience_path)
        .onChange((value) =>
          __async(this, null, function* () {
            const next = __spreadValues({}, this.plugin.settings)
            next.vault_ambience_path = value
            yield this.plugin.updateSettings(next)
          })
        )
      result.inputEl.addClass('input-field')
      this._SETTING_VAULT_PATH_INPUT = result
    }
    return this._SETTING_VAULT_PATH_INPUT
  }
  get SETTING_AMBIENCE_PER_FILE() {
    if (!this._SETTING_AMBIENCE_PER_FILE) {
      this._SETTING_AMBIENCE_PER_FILE = new import_obsidian.Setting(this.containerEl)
        .setName('Ambience per files:')
        .setDesc(
          "If enabled, plugin would try to apply your embed URL as audio for the files's ambience specifically: meaning one file got one ambience and etc., prioritised over vault's ambience (vault ambience would stop playing)."
        )
        .addToggle((toggle) => {
          toggle.setValue(this.plugin.settings.ambience_per_files).onChange((value) =>
            __async(this, null, function* () {
              const next = __spreadProps(__spreadValues({}, this.plugin.settings), {
                ambience_per_files: value
              })
              yield this.plugin.updateSettings(next)
            })
          )
          return toggle
        })
    }
    return this._SETTING_AMBIENCE_PER_FILE
  }
  get SETTING_AMBIENCE_PER_FILE_COMMENT() {
    if (!this._SETTING_AMBIENCE_PER_FILE_COMMENT) {
      this._SETTING_AMBIENCE_PER_FILE_COMMENT = new import_obsidian.Setting(this.containerEl)
        .setName('')
        .setDesc(
          'To apply custom ambience to file, insert into the metadata cache of the file (YAML) "music" variable with URL or path to your audio.'
        )
    }
    return this._SETTING_AMBIENCE_PER_FILE_COMMENT
  }
  get SETTING_MUSIC_VOLUME() {
    if (!this._SETTING_MUSICE_VOLUME) {
      this._SETTING_MUSICE_VOLUME = new import_obsidian.Setting(this.containerEl)
        .setName('Music volume')
        .setDesc(
          "Control volume of YouTube/Local audios. Audio from SoundCloud doesn't support this feature."
        )
        .addSlider((slider) => {
          slider
            .setDynamicTooltip()
            .setLimits(
              this.plugin.settings.MIN_VOLUME,
              this.plugin.settings.MAX_VOLUME,
              this.plugin.settings.VOLUME_STEP
            )
            .onChange((value) =>
              __async(this, null, function* () {
                const next = __spreadProps(__spreadValues({}, this.plugin.settings), {
                  music_volume: value
                })
                this.plugin.updateVolumeSettings(next)
              })
            )
        })
    }
    return this._SETTING_MUSICE_VOLUME
  }
  get SETTING_DEBUG_FRAMES() {
    if (!this._SETTING_DEBUG_FRAMES) {
      this._SETTING_DEBUG_FRAMES = new import_obsidian.Setting(this.containerEl)
        .setName('Debug frames:')
        .setDesc(
          'Allows you to view frames generated by this plugin, meaning you can view mini-players for music/video.'
        )
        .addToggle((toggle) => {
          toggle.setValue(this.plugin.settings.debug_frames).onChange((value) =>
            __async(this, null, function* () {
              const next = __spreadProps(__spreadValues({}, this.plugin.settings), {
                debug_frames: value
              })
              yield this.plugin.updateSettings(next)
            })
          )
        })
    }
    return this._SETTING_DEBUG_FRAMES
  }
  static updateDisplays(elements, values) {
    if (elements.length !== values.length)
      throw new Error('Elements and their values both are out of range in some other ways.')
    for (let i = 0; i < elements.length; i++) {
      const element = elements[i]
      if (element instanceof import_obsidian.Setting)
        element.settingEl.style.display = values[i] ? 'block' : 'none'
      if (element instanceof import_obsidian.TextAreaComponent)
        element.inputEl.style.display = values[i] ? 'block' : 'none'
    }
  }
  _updateState(data, prev, next) {
    if (prev !== next) {
      if (prev) {
        if (!this.defaults) {
          this.defaults = {
            color: data.inputEl.style.color,
            borderColor: data.inputEl.style.borderColor,
            borderWidth: data.inputEl.style.borderWidth
          }
        }
        data.inputEl.style.color = 'red'
        data.inputEl.style.borderColor = 'red'
        data.inputEl.style.borderWidth = '4px'
      } else if (this.defaults) {
        data.inputEl.style.color = this.defaults.color
        data.inputEl.style.borderColor = this.defaults.borderColor
        data.inputEl.style.borderWidth = this.defaults.borderWidth
      }
    }
  }
}

// source/settings.ts
var WhispererSettingsTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin)
    __publicField(this, 'plugin')
    this.plugin = plugin
  }
  display() {
    const { containerEl } = this
    containerEl.empty()
    const settingsConstructor = new SettingsConstructor(this.plugin, containerEl)
    const items = [
      settingsConstructor.SETTING_AMBIENCE,
      settingsConstructor.SETTING_VAULT_PATH_TITLE,
      settingsConstructor.SETTING_VAULT_PATH_INPUT,
      settingsConstructor.SETTING_AMBIENCE_PER_FILE,
      settingsConstructor.SETTING_AMBIENCE_PER_FILE_COMMENT,
      settingsConstructor.SETTING_DEBUG_FRAMES
    ]
    SettingsConstructor.updateDisplays(
      [items[1], items[2]],
      [this.plugin.settings.vault_ambience, this.plugin.settings.vault_ambience]
    )
  }
}

// source/settings/settings.ts
var DEFAULT_SETTINGS = {
  vault_ambience: false,
  vault_ambience_path: '',
  ambience_per_files: true,
  music_volume: 50,
  debug_frames: false,
  MIN_VOLUME: 0,
  MAX_VOLUME: 100,
  VOLUME_STEP: 1
}

// source/utils/functions.ts
function isUrl(str) {
  return /^(https?:\/\/)/.test(str)
}
function getEmbedUrl(url) {
  if (url.includes('youtube.com') || url.includes('youtu.be')) {
    const videoId = url.includes('youtu.be')
      ? url.split('/').pop()
      : new URL(url).searchParams.get('v')
    return `https://www.youtube.com/embed/${videoId}?autoplay=1&start=0`
  } else if (new URL(url).host === 'soundcloud.com' || new URL(url).host === 'www.soundcloud.com') {
    return `https://w.soundcloud.com/player/?url=${encodeURIComponent(url)}&auto_play=true`
  }
  throw new Error('Unsupported URL type.')
}
function extractId(url) {
  const match = url.match(/(?:youtu\.be\/|youtube\.com\/(?:embed\/|v\/|.*v=))([\w-]{11})/)
  return match ? match[1] : ''
}

// source/player/player_per_file.ts
var PlayerPerFile = class {
  constructor(_plugin) {
    __publicField(this, 'plugin')
    this.plugin = _plugin
  }
  handleFileOpen(file) {
    return __async(this, null, function* () {
      var _a
      if (!file) return
      if (!this.plugin.settings.ambience_per_files) return
      const fileCache = this.plugin.app.metadataCache.getFileCache(file)
      const musicPath =
        (_a = fileCache == null ? void 0 : fileCache.frontmatter) == null ? void 0 : _a.music
      if (musicPath) {
        this.pauseVaultAmbience()
        if (this.plugin.activeFile) {
          this.pauseFileAmbience(this.plugin.activeFile)
        }
        this.plugin.activeFile = file.path
        this.playFileAmbience(musicPath, file.path)
      } else {
        if (this.plugin.activeFile) {
          this.pauseFileAmbience(this.plugin.activeFile)
        }
        if (
          !document
            .getElementsByClassName('obsidian-app')[0]
            .querySelector('.vault-ambience-player')
        ) {
          if (this.plugin.settings.vault_ambience) this.plugin.playerPerGlobal.playAmbience()
        }
      }
    })
  }
  playFileAmbience(musicPath, filePath) {
    const container = document.getElementsByClassName('obsidian-app')[0]
    if (!container) return
    const player = document.createElement('div')
    player.className = 'file-ambience-player'
    if (isUrl(musicPath)) {
      if (musicPath.includes('youtube.com') || musicPath.includes('youtu.be')) {
        const videoId = extractId(musicPath)
        const iframe = document.createElement('iframe')
        iframe.src = `https://www.youtube.com/embed/${videoId}?autoplay=1&loop=1&playlist=${videoId}`
        iframe.width = '300'
        iframe.height = '166'
        iframe.allow = 'autoplay'
        iframe.addClass(this.plugin.settings.debug_frames ? 'visible' : 'hidden-frame')
        player.appendChild(iframe)
      } else {
        try {
          const parsedUrl = new URL(musicPath)
          const allowedHosts = ['soundcloud.com']
          if (allowedHosts.includes(parsedUrl.host)) {
            const embedUrl = getEmbedUrl(musicPath)
            const iframe = document.createElement('iframe')
            iframe.src = embedUrl
            iframe.width = '300'
            iframe.height = '166'
            iframe.allow = 'autoplay'
            iframe.addClass(this.plugin.settings.debug_frames ? 'visible' : 'hidden-frame')
            player.appendChild(iframe)
          }
        } catch (e) {
          console.error('Invalid URL:', musicPath, e)
        }
      }
    } else {
      const audio = document.createElement('audio')
      audio.src = this.plugin.app.vault.adapter.getResourcePath(musicPath)
      audio.controls = true
      audio.autoplay = true
      audio.loop = true
      audio.volume = (this.plugin.settings.music_volume || 50) / 100
      player.appendChild(audio)
      audio.addEventListener('timeupdate', () => {
        const playbackData = this.plugin.fileAmbiencePlayers.get(filePath)
        if (playbackData) {
          playbackData.position = audio.currentTime
        }
      })
    }
    container.appendChild(player)
    this.plugin.fileAmbiencePlayers.set(filePath, { player, position: 0 })
  }
  pauseFileAmbience(filePath) {
    var _a, _b
    const playbackData = this.plugin.fileAmbiencePlayers.get(filePath)
    if (!playbackData) return
    const { player } = playbackData
    if (player instanceof HTMLAudioElement) {
      playbackData.position = player.currentTime
      player.pause()
    } else if (player instanceof HTMLIFrameElement) {
      if (player.src.includes('youtube.com') || player.src.includes('youtu.be')) {
        ;(_a = player.contentWindow) == null
          ? void 0
          : _a.postMessage(JSON.stringify({ event: 'command', func: 'pauseVideo', args: [] }), '*')
      } else {
        try {
          const parsedUrl = new URL(player.src)
          const allowedHosts = ['soundcloud.com']
          if (allowedHosts.includes(parsedUrl.host)) {
            ;(_b = player.contentWindow) == null
              ? void 0
              : _b.postMessage(JSON.stringify({ method: 'pause' }), '*')
          }
        } catch (e) {
          console.error('Invalid URL in player.src:', player.src, e)
        }
      }
    }
    player.remove()
    this.plugin.fileAmbiencePlayers.delete(filePath)
  }
  pauseVaultAmbience() {
    this.plugin.unapply()
  }
}

// source/player/factory/player_factory.ts
var PlayerFactory = class {
  static createPlayer(plugin, player, type) {
    switch (type) {
      case 'youtube':
      case 'yt':
      case 'ytube':
        this.setupYouTubePlayer(plugin, player)
        break
      case 'sc':
      case 'scloud':
      case 'soundcloud':
        this.setupSoundCloudPlayer(plugin, player)
        break
      case 'local':
      case 'audio':
      case 'fs':
        this.setupLocalAudioPlayer(plugin, player)
        break
      default:
        throw new Error('Got an unknown type of player!')
    }
  }
  static setupYouTubePlayer(plugin, player) {
    const videoId = extractId(plugin.settings.vault_ambience_path)
    const iframe = document.createElement('iframe')
    iframe.src = `https://www.youtube.com/embed/${videoId}?autoplay=1&loop=1&enablejsapi=1&playlist=${videoId}`
    iframe.width = '300'
    iframe.height = '166'
    iframe.allow = 'autoplay'
    iframe.allowFullscreen = true
    iframe.onload = () => {
      var _a
      const volume = plugin.settings.music_volume || 50
      ;(_a = iframe.contentWindow) == null
        ? void 0
        : _a.postMessage(
            JSON.stringify({
              event: 'command',
              func: 'setVolume',
              args: [volume]
            }),
            '*'
          )
    }
    player.appendChild(iframe)
  }
  static setupSoundCloudPlayer(plugin, player) {
    const embedUrl = getEmbedUrl(plugin.settings.vault_ambience_path)
    const apiEnabledUrl = `${embedUrl}&visual=true&show_artwork=false`
    const iframe = document.createElement('iframe')
    iframe.src = apiEnabledUrl
    iframe.width = '300'
    iframe.height = '166'
    iframe.allow = 'autoplay'
    player.appendChild(iframe)
  }
  static setupLocalAudioPlayer(plugin, player) {
    const audio = document.createElement('audio')
    audio.src = plugin.app.vault.adapter.getResourcePath(plugin.settings.vault_ambience_path)
    audio.controls = true
    audio.autoplay = true
    audio.loop = true
    audio.volume = (plugin.settings.music_volume || 50) / 100
    audio.addEventListener('volumechange', () => {
      plugin.settings.music_volume = audio.volume * 100
      plugin.saveData(plugin.settings)
    })
    player.appendChild(audio)
  }
}

// source/player/player_per_global.ts
var PlayerPerGlobal = class {
  constructor(_plugin) {
    __publicField(this, 'plugin')
    this.plugin = _plugin
  }
  playAmbience() {
    const container = document.getElementsByClassName('obsidian-app')[0]
    if (!container) return
    let player = container.querySelector('.vault-ambience-player')
    if (player) player.remove()
    if (container.getElementsByClassName('file-ambience-player').length > 0) return
    player = document.createElement('div')
    player.className = 'vault-ambience-player'
    player.addClass(this.plugin.settings.debug_frames ? 'visible' : 'hidden-frame')
    if (isUrl(this.plugin.settings.vault_ambience_path)) {
      const url = new URL(this.plugin.settings.vault_ambience_path)
      const allowedYouTubeHosts = ['youtube.com', 'youtu.be']
      const allowedSoundCloudHosts = ['soundcloud.com']
      if (allowedYouTubeHosts.includes(url.host)) {
        PlayerFactory.createPlayer(this.plugin, player, 'yt')
      } else if (allowedSoundCloudHosts.includes(url.host)) {
        PlayerFactory.createPlayer(this.plugin, player, 'sc')
      }
      PlayerFactory.createPlayer(this.plugin, player, 'local')
    }
    container.appendChild(player)
    this.plugin.players.push(player)
  }
}

// source/main.ts
var Whisperer = class _Whisperer extends import_obsidian3.Plugin {
  constructor() {
    super(...arguments)
    __publicField(this, '_settings', DEFAULT_SETTINGS)
    __publicField(this, 'players', [])
    __publicField(this, 'fileAmbiencePlayers', /* @__PURE__ */ new Map())
    __publicField(this, 'activeFile', null)
    __publicField(this, 'playerPerFile', new PlayerPerFile(this))
    __publicField(this, 'playerPerGlobal', new PlayerPerGlobal(this))
  }
  get settings() {
    return this._settings
  }
  onload() {
    return __async(this, null, function* () {
      __superGet(_Whisperer.prototype, this, 'onload').call(this)
      yield this.loadSettings()
      this.addSettingTab(new WhispererSettingsTab(this.app, this))
      this.registerEvent(
        this.app.workspace.on('file-open', this.playerPerFile.handleFileOpen.bind(this))
      )
      const container = document.getElementsByClassName('obsidian-app')[0]
      if (container) {
        const script = document.createElement('script')
        script.src = 'https://w.soundcloud.com/player/api.js'
        script.id = 'whisperer-md-sc-widget'
        container.appendChild(script)
      }
      this.apply()
    })
  }
  onunload() {
    return __async(this, null, function* () {
      __superGet(_Whisperer.prototype, this, 'onunload').call(this)
      const script = document.getElementById('whisperer-md-sc-widget')
      if (script) {
        script.src = ''
        script.remove()
      }
      this.unapply()
    })
  }
  loadSettings() {
    return __async(this, null, function* () {
      this._settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData())
    })
  }
  updateSettings(settings) {
    return __async(this, null, function* () {
      this.unapply()
      this._settings = settings
      yield this.saveData(this.settings)
      this.apply()
    })
  }
  updateVolumeSettings(settings) {
    return __async(this, null, function* () {
      if (this.players.length === 0) {
        this.updateSettings(settings)
      } else {
        this._settings = settings
        yield this.saveData(this.settings)
        this.players.forEach((player) => {
          var _a, _b
          if (player.tagName === 'IFRAME') {
            const iframe = player
            try {
              const url = new URL(iframe.src)
              const allowedYouTubeHosts = ['youtube.com', 'www.youtube.com', 'youtu.be']
              if (allowedYouTubeHosts.includes(url.hostname)) {
                ;(_a = iframe.contentWindow) == null
                  ? void 0
                  : _a.postMessage(
                      JSON.stringify({
                        event: 'command',
                        func: 'setVolume',
                        args: [this.settings.music_volume]
                      }),
                      '*'
                    )
              }
            } catch (e) {
              console.error('Invalid iframe src URL:', iframe.src, e)
            }
            try {
              const url = new URL(iframe.src)
              const allowedSoundCloudHosts = ['soundcloud.com', 'w.soundcloud.com']
              if (allowedSoundCloudHosts.includes(url.hostname)) {
                ;(_b = iframe.contentWindow) == null
                  ? void 0
                  : _b.postMessage(
                      JSON.stringify({
                        method: 'setVolume',
                        value: this.settings.music_volume / 100
                      }),
                      'https://w.soundcloud.com'
                    )
              }
            } catch (e) {
              console.error('Invalid iframe src URL:', iframe.src, e)
            }
          } else if (player.tagName === 'AUDIO') {
            const audio = player
            audio.volume = (this.settings.music_volume || 50) / 100
          }
        })
      }
    })
  }
  updateVisibleSettings(settings) {
    return __async(this, null, function* () {
      if (this.players.length === 0) {
        this.updateSettings(settings)
      } else {
        this._settings = settings
        yield this.saveData(this.settings)
        this.players.forEach((player) => {
          player.removeClass(this.settings.debug_frames ? 'hidden-frame' : 'visible')
          player.addClass(this.settings.debug_frames ? 'visible' : 'hidden-frame')
        })
      }
    })
  }
  unapply() {
    this.players.forEach((player) => {
      player.remove()
      const iframe = player.querySelector('iframe')
      if (iframe) {
        iframe.src = ''
      }
    })
    this.players = []
    for (const playerData of this.fileAmbiencePlayers.values()) {
      playerData.player.remove()
    }
  }
  apply() {
    if (this.settings.vault_ambience) this.playerPerGlobal.playAmbience()
  }
}
//! Volume adjustment is not directly supported by SoundCloud embedded players.
